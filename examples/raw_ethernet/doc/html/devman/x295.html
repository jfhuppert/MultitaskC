<HTML
><HEAD
><TITLE
>Frequently asked questions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
HREF="t1.html"><LINK
REL="PREVIOUS"
TITLE="The development environment of Etherboot"
HREF="x233.html"><LINK
REL="NEXT"
TITLE="Writing an Etherboot Driver"
HREF="driver.html"></HEAD
><BODY
CLASS="sect1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x233.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="driver.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN295"
></A
>Frequently asked questions</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN297"
></A
>How portable is Etherboot?</H2
><P
>&#13;Work leading up to 5.2 made Etherboot much more portable. The platforms
on which Etherboot runs, other than the x86, are the Itanium and the
Hammer. The portability issues can be looked at in two categories:

</P
><P
>&#13;Support routines needed for platforms need to be written.  Platform
independent and dependent code have been separated and it should be
straightforward to identify the support that is needed for running
Etherboot on a new platform.

</P
><P
>&#13;Byte order, operand size and alignment issues in the core routines and
PCI drivers have been mostly dealt with, although there are some known
places where the code has not been made portable, e.g. longword access
of registers in the eepro100 driver.  We hope to find these bugs as time
goes by. In some cases, e.g. ISA bus NICs, there is no need to fix the
problem as the ISA bus only exists on the PC platform (unless somebody
attaches a NE2000 to a big-endian microcontroller and plans to run
Etherboot on it).

</P
><P
>&#13;Here are the low-level services that need to provided: writing and
reading from the console, determining the size of memory, obtaining the
an elapsed time, inserting a boot vector to be called, and a microsecond
timer for short delays.  Depending on the target environment, these
services may be provided in different ways.

</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN303"
></A
>How can I get Etherboot to boot a Cardbus (PCMCIA) or a USB NIC?</H2
><P
>&#13;Cardbus (PCMCIA) and USB NICs are interfaced to the CPU through their
respective bus controllers. Before Etherboot can address the registers
and memory on these NICs, it must initialise the bus controller
appropriately. In Linux this is done by the PCMCIA and USB subsystems.
In Etherboot, all this must be done by the code in the ROM. What needs
to be written is a subsystem like the PCI subsystem in Etherboot.
Volunteers are most welcome.

</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x233.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="driver.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The development environment of Etherboot</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Writing an Etherboot Driver</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>