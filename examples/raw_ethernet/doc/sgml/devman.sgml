<?xml version='1.0' encoding='ISO-8859-1'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article>

<articleinfo>

<title>Etherboot Developers Manual</title>
<authorgroup>
<author>
<firstname><ulink url="ken_yapATusersPERIODsourceforgePERIOD net">Ken</ulink></firstname><surname>Yap</surname>
</author>
<author>
<firstname><ulink url="gbaumATusersPERIODsourceforgePERIODnet">Georg</ulink></firstname><surname>Baum</surname>
</author>
</authorgroup>
<copyright><year>2001</year><year>2002</year><year>2003</year><holder>Ken Yap</holder></copyright>
<copyright><year>2003</year><holder>Georg Baum</holder></copyright>
<releaseinfo>5.2.2</releaseinfo>
<pubdate>2003-90-30</pubdate>
<revhistory>
<revision><revnumber>5.2.2</revnumber><date>2003-00-30</date><authorinitials>KY</authorinitials></revision>
<revision><revnumber>5.2.0</revnumber><date>2003-08-11</date><authorinitials>KY, GB</authorinitials></revision>
</revhistory>

<abstract>

<para>
This document explains the internals of the Etherboot package.  The
information here applies to version 5.2 of Etherboot.
</para>

</abstract>

</articleinfo>

<sect1>
<title>About this Developers Manual</title>

<sect2>
<title>Obtaining the most recent version of this document</title>

<para>
This document and related documents are also kept online at <ulink
url="http://etherboot.sourceforge.net/">the Etherboot Home Page</ulink>.
This will in general have the latest source distributions and
documentation.

</para>
</sect2>

<sect2>
<title>Feedback</title>

<para>
Comments on and corrections for this Developers Manual may be directed to the
<ulink url="mailto:ken_yapATusersPERIODsourceforgePERIODnet">primary
author</ulink>.

</para>
</sect2>

<sect2>
<title>Copyrights and Trademarks</title>

<para>
This manual may be reproduced in whole or in part, without fee, subject
to the following restrictions:

</para>
<para>

<itemizedlist>
<listitem>

<para>
The copyright notice above and this permission notice must be
preserved complete on all complete or partial copies.

</para>
</listitem>
<listitem>

<para>
Any translation or derived work must be approved by the author in
writing before distribution.

</para>
</listitem>
<listitem>

<para>
If you distribute this work in part, instructions for obtaining
the complete version of this manual must be included, and a means for
obtaining a complete version provided.

</para>
</listitem>
<listitem>

<para>
Small portions may be reproduced as illustrations for reviews or
quotes in other works without this permission notice if proper citation
is given. Exceptions to these rules may be granted for academic
purposes: Write to the author and ask. These restrictions are here to
protect us as authors, not to restrict you as learners and educators.

</para>
</listitem>

</itemizedlist>

</para>
<para>
All trademarks mentioned in this document belong to their respective
owners.

</para>
</sect2>

<sect2>
<title>Acknowledgements and Thanks</title>

<para>
Thanks to all the people who have contributed information and
corrections to this document.

</para>
</sect2>

</sect1>

<sect1>
<title>Characteristics of Etherboot</title>

<para>
For an introduction to Etherboot from the user perspective you may wish
to read the <ulink url="../userman/t1.html">User Manual</ulink> first.

</para>
<para>
In order to understand Etherboot development, it is necessary to first
understand how Etherboot differs from normal application programs.

</para>
<para>

<orderedlist>
<listitem>

<para>
Etherboot runs as a standalone program, not under an operating
system. The only services it relies on are those provided by the BIOS of
the motherboard, or LinuxBIOS.

</para>
</listitem>
<listitem>

<para>
It has complete access to the "bare metal" of the machine.

</para>
</listitem>
<listitem>

<para>
It needs to have as small a memory footprint as practicable, in
order to maximise the amount of memory available to the code that it
loads.

</para>
</listitem>

</orderedlist>

</para>

</sect1>

<sect1 id="extension">
<title>The execution environment of Etherboot</title>

<sect2>
<title>The network booting process</title>

<para>
Since this is the part that the user sees first, let us first demystify
how network booting works.

</para>
<para>
From time immemorial, well actually since the IBM XT appeared on the
market, the PC architecture has a mechanism for invoking "extension
BIOSes". The original reason for this mechanism was to allow adaptor
cards that the main BIOS didn't know how to deal with to carry ROMs with
initialisation code or drivers.  An early example was the XT hard disk
controller. The main BIOS of XTs only knew how to boot from floppies.
When an XT hard disk controller is added, the code in the ROM on the
controller appears in the memory space of the PC and is called as part
of the machine initialisation. Another example is the BIOSes on VGA
video adaptor cards, although strictly speaking that is a special case
in terms of ROM address. When network adaptors were made for the PC, it
was a natural step to put ROMs on them that could contact a server for
network booting.

</para>
<para>
How does the main BIOS know that the code in the ROM is to be executed
and why does it not execute some random code by accident? The ROM code
has several conditions placed on it.

</para>
<para>

<itemizedlist>
<listitem>

<para>
The ROM must start on a 2kB boundary in the memory space, between
0xC8000 and 0xEE000, although some main BIOSes scan outside these limits.

</para>
</listitem>
<listitem>

<para>
The first two bytes of the ROM must be 55 AA hex.

</para>
</listitem>
<listitem>

<para>
The third byte of the ROM should contain the number of bytes in
the ROM code divided by 512. So if the ROM code is 16kB long, then this
byte would hold 20 hex (32 decimal).

</para>
</listitem>
<listitem>

<para>
All the bytes in the ROM (specified by the length byte just
mentioned) must checksum to 8 bits of binary zero. The sum is formed by
8 bit addition of all the bytes, throwing away the carry. Note that
there is not a particular location designated as the "checksum byte".
Normally the ROM building process alters an unused byte somewhere to
fulfil the checksum condition.

</para>
</listitem>

</itemizedlist>

</para>

<para>
If such a ROM is detected and validated by a scan, then the main BIOS
does a far call to ROMSEG:3, where ROMSEG is the segment of the ROM and
3 is the offset to transfer control to the discovered extension BIOS.
Typically a network boot ROM does not take full control at this point.
Instead the normal procedure to do some initialisation or probing of the
hardware and then plant a vector that will be called when the BIOS is
ready to boot the OS. The vector used for this purpose is normally
interrupt 0x19 although interrupt 0x18 is sometimes used.

</para>
<para>
For PCI plug and play ROMs things are more complicated. For the full
story, you need to get the specifications from Phoenix and Intel. Here
is a quick summary.

</para>
<para>

<itemizedlist>
<listitem>

<para>
The boot ROM must satisfy the requirements for ROMs listed above
(called legacy ROMs).

</para>
</listitem>
<listitem>

<para>
There are two additional structures in the ROM, the PCIR structure
and the PnP structure. These structures are pointed to by offsets in two
16-bit words at 0x18 and 0x1A bytes respectively from the beginning of
the ROM. As a double check, the structures each begin with 4 magic
bytes, PCIR and $PnP respectively.

</para>
</listitem>
<listitem>

<para>
The PCIR structure contains the vendor and device IDs of the
network adaptor, and these must match the IDs that is stored in the
adaptor's PCI configuration memory, or the ROM will be ignored.

</para>
</listitem>
<listitem>

<para>
The PnP structure contains various vectors. The one of interest to
us is the Boot Execution Vector (BEV). This points to the starting point
of the boot ROM code. The first time the ROM is detected, it is called
at the ROMSEG+3 entry point as for legacy ROMs. This entry point must
indicate, by returning 0x20 in register AX, that it is a network boot
device. When the BIOS is ready to boot, it calls the BEV. Note that the
BIOS only calls the BEV if the BIOS configuration specifies the device
in the boot sequence.

</para>
</listitem>
<listitem>

<para>
There is a checksum for the PnP structure in addition to the
overall checksum in legacy ROMs.

</para>
</listitem>
</itemizedlist>
</para>

<para>
The network boot process then works like this:

</para>
<para>

<orderedlist>
<listitem>

<para>
The main BIOS detects the Etherboot ROM as an extension BIOS and passes
control to it with a far call.

</para>
</listitem>
<listitem>

<para>
For legacy ROMs, the Etherboot code hooks itself to interrupt 0x19
and returns control to the main BIOS. For PnP ROMs the Etherboot code
indicates that it is a bootable device.

</para>
</listitem>
<listitem>

<para>
The main BIOS finishes initialising other devices and boots the
operating system by calling interrupt 0x19.

</para>
</listitem>
<listitem>

<para>
The Etherboot code gains control.

</para>
</listitem>
<listitem>

<para>
It initialises the network hardware so that it is ready to send
and receive packets.

</para>
</listitem>
<listitem>

<para>
It sends a Boot Protocol (<ulink
url="http://www.ietf.org/rfc/rfc951.txt">BOOTP</ulink>) or Dynamic Host
Configuration Protocol (<ulink
url="http://www.ietf.org/rfc/rfc2131.txt">DHCP</ulink>) broadcast query
packet.  An alternative is Reverse Address Resolution Protocol (<ulink
url="http://www.ietf.org/rfc/rfc903.txt">RARP</ulink>)

</para>
</listitem>
<listitem>

<para>
Assuming a reply is received, the Etherboot code decodes the fields of
the reply, sets its IP address and other parameters, and sends a Trivial
File Transfer Protocol (<ulink
url="http://www.ietf.org/rfc/rfc1350.txt">TFTP</ulink>) request to
download the file. Be aware that the 16-bit counter field of TFTP may
limit transfers to 16 MB (signed interpretation), 32 MB (unsigned
interpretation) or 90 MB (unsigned, large block size option active).
This is a rollover bug in many TFTP servers, but quite prevalent. An
alternative loading protocol is Network File System (<ulink
url="http://www.ietf.org/rfc/rfc1094.txt">NFS</ulink>) protocol.  In
this instance a mount of the remote filesystem is done (with the bare
minimum of features) and the boot file is read off the filesystem.

</para>
</listitem>
<listitem>
<para>
The file to be loaded is in a special format, it contains a "directory"
in the first block that specifies where in memory the various pieces of
the file are to be loaded. Formats that are supported are tagged <xref
linkend="tagged"/> or <ulink
url="http://www.acm.uiuc.edu/sigops/rsrc/pfmt11.pdf">Execution and
Loader Format (ELF)</ulink>. One small extension to ELF has been made,
the top bit in the e_flags longword of the ELF header has been used as
ELF_PROGRAM_RETURNS_BIT, meaning that the program transferred to intends
to return to Etherboot, e.g. a menu program, and that Etherboot should
not disable the network interface yet. See the file
<filename>core/osloader.c</filename>.

</para>
<para>
Eric Biederman adds: The ELF format is documented in the <ulink
url="http://www.sco.com/developer/devspecs/gabi41.pdf">SysV Generic ABI
doc</ulink>.  <ulink
url="http://www.sco.com/developer/devspecs/abi386-4.pdf">http://www.sco.com/developer/devspecs/abi386-4.pdf</ulink>
Also check out the <ulink url="http://www.linuxbase.org/spec/">linux
standard base</ulink>, it has good links to all of these documents, in
its related documents section.

</para>
</listitem>
<listitem>

<para>
Etherboot transfers control to the loaded image.

</para>
</listitem>
</orderedlist>
</para>

<para>
Notice no assumption was made that the image is a Linux kernel. Even
though loading Linux kernels is the most common use of Etherboot, there
is nothing in the procedure above that is Linux specific. By creating
the loaded file appropriately, different operating systems, e.g.
FreeBSD, DOS, can be loaded.

</para>
<para>
In the case of a Linux kernel, there is some additional work to be done
before the kernel can be called, so the segment of the file that
Etherboot transfers to is not the startup segment of the kernel, but an
initial stub, whose code is in <filename>first32.c</filename> in the
mknbi package. This stub has several
tasks, which either cannot be done by Etherboot, or should not be done
by Etherboot because they are Linux specific. These are: to append
kernel arguments from option 129 of the BOOTP or DHCP reply; to copy and
expand special kernel parameters, in particular the vga= and the ip=
parameters and then to point the kernel to the location of the parameter
area; to move the RAMdisk, if there is one, to the top of memory (this
last cannot be done at image creation time since the size of the RAM of
the machine is not known then).

</para>
<para>
The kernel parameters are passed to the kernel as a pointer to the
string written in a certain location in the original bootblock
(<filename>boot.S</filename> from the Linux kernel sources). This is a
16-bit pointer and is the offset of the parameter area from the base of
the bootblock. This is one reason why the parameter area must be in the
same 64kB as the bootblock.  If the components of Etherboot are to be
relocated elsewhere, e.g.  0x80000 upwards, then they should be
relocated together.  In version 0x0202 and above of the Linux setup
segment, this can be passed instead as a absolute 32-bit pointer in a
certain location in the setup segment.  This eases the relocation
requirements.  The address of the RAM disk, if it exists, is passed to
the kernel as a 32-bit address in a particular location in the setup
segment (<filename>setup.S</filename> from the Linux kernel sources).
This is filled in with the final location of the RAM disk after it has
been moved to the top of memory.

</para>
</sect2>

<sect2>
<title>To compress or not to compress, that is the question</title>

<para>
We simplified things a little when we talked about how the main BIOS
detects the Etherboot ROM and passes control to it. At this point the
code is executing from ROM. There are two problems with executing from
ROM where x86 PCs are concerned.

</para>
<para>

<orderedlist>
<listitem>

<para>
The x86 architecture does not easily support Position Independent
Code (PIC). The main drawback when executing C code is referencing
global entities (global and static variables). Since the ROM address is
not known when building the image, addresses cannot be assigned to
global entities. More advanced environments have a dynamic loader for
adjusting references just before use. Etherboot has no such help. If the
code were written in assembler, we could use a convention like always
referencing global entities as offsets from a particular register. But
we don't want to write in assembler and we don't have control over what
the C compiler generates.

</para>
</listitem>
<listitem>

<para>
C code assumes that data locations are writable. ROM locations are
not writable, by definition. One could remedy this by locating the
writable entities in a RAM segment, but this causes more complication.

</para>
</listitem>

</orderedlist>

</para>

<para>
For the reasons above, Etherboot copies itself to the top of memory or 4
GB, whichever is the lesser, and executes there. However that is the
physical address. The logical address for execution is set in the
Makefile and currently is 0x20000 for the x86 version. The translation
is done using the address translation facility of the MMU. This allows
Etherboot global variables and functions to be assigned known addresses
at the linking step.

</para>
<para>
(Actually top of memory isn't completely true. On the x86 platform it
executes in an even megabyte just below the top of memory. This is
normally the second last megabyte. The reason has to do with the setting
of the A20 gate. If Etherboot executes in an odd megabyte it will get
gated out of existence when the A20 gate is disabled. By running in an
even megabyte this is avoided. Note that we still have to disable the
A20 gate because some operating systems react strangely if they find it
enabled when they are expecting it not to be, but now we can do it from
C instead of from real mode asm running in the lower 640kB.)

</para>
<para>
This gives us about 1 MB for code, data, and stack.  There is no heap as
is normally understood; Etherboot does not have dynamic storage
allocation. This keeps things simple, makes it a bit less prone to
programming errors, and also acts as a check against unthinking use of
memory by programmers. There is however a small heap which can be used
to provide small allocations of memory below 640 kB.

</para>
<para>
The ROM loader copies the payload to a temporary location starting at
0x80000 and continues execution from there. The reason for this first
relocation is so that execution goes faster.  Typically ROM has longer
access times than RAM and is often accessed 8 bits at a time. The glue
chipsets used in motherboards add wait states so that the CPU can
interface with relatively slow ROM. This is to reduce ROM costs, as
execution speed is not important at boot time. By copying itself to RAM
first, the decompression goes faster.  After relocation and resumption
of execution, for the x86 platform, the loader then jumps to start16,
which switches into protected mode, then this jumps to start32.  On
other platforms, there is no need to switch modes so it jumps to the
beginning of the code directly.  Other loaders are used when the code
is not run from ROM but they also have the ultimate action of jumping to
start16.

</para>
<para>
We usually want to minimise the size of the ROM used to hold Etherboot.
Even if the network adapter accommodates large ROMs, there are many
claims on the area between 0xC8000 to 0xEE000, by other extension
BIOSes, by peripherals that use shared memory, and so forth.  Compressed
images are suffixed with .z*. The payload is a .zimg file.  The first
part of a .zimg file is the decompressor which decompresses its own
payload to the intended execution location. The decompressor is
assembled from <filename>arch/i386/prefix/unnrv2b.S</filename>.  The
second part is the .img result of a compilation.  In non-compressed
images, the .img is the one and only part in the payload.  Compressed
.zrom images should work just the same as .rom images, but are smaller
(but this saving may or may not bring it below a particular ROM chip
capacity which are powers of two).  The compressor is a C program called
<filename>util/nrv2b.c</filename>. This is run on the host platform when
building images.

</para>
<para>
Here is a diagram of a full prefix stack for the x86 architecture. Other
architectures will not have the real mode to protected mode transition
and will have different runtime routines and decompressor:

<programlisting>
+-----------------------+
|                       |
| Payload               | *.img
+-----------------------+
|                       |
| Decompressor          | unnrv2b.S
+-----------------------+
|                       |
| PM runtime routines   | start32.S
+-----------------------+
|                       |
| RM to PM transition   | start16.S
+-----------------------+
|                       |
| Media specific loader | loader.S, *prefix.S
+-----------------------+
</programlisting>

</para>
</sect2>

<sect2>
<title>Real and protected mode</title>

<para>
One of the complications of the x86 architecture is the existence of the
real and protected modes of execution. To simplify a long story, if we
want to execute 32-bit code as generated by the C compiler, we need to
be in protected mode. However the processor boots up in real mode, which
is 16-bit. So the loaders must execute in real mode. In addition, the
main BIOS calls the extension BIOS in real mode. So at least the
prologue of the main code must be in real mode. BIOS calls must also be
in real mode. In Etherboot this is handled by a pair of functions
(written in assembler of course) called
<function>prot_to_real</function> and <function>real_to_prot</function>
that do the switching. The C code doesn't call this directly. They are
implicitly called from routines that use BIOS services, such as printing
characters to the screen or reading characters from the keyboard.  In
Etherboot 5.2 and above, the 16-bit code is executed inside special
segments of memory created on the fly for running real-mode code
fragments, as opposed to previous versions, where they ran inline with
the 32-bit code. This allows the 32-bit stack to be separate from the
16-bit one.

</para>
<para>
The file <filename>first32</filename> establishes a 32-bit stack which
is separate from the 16-bit one and uses that thereafter.

</para>
</sect2>
</sect1>

<sect1>
<title>The architecture of Etherboot</title>

<para>
Leaving aside the peripheral code for the loaders, the rest of Etherboot
can be divided into the core, the drivers and miscellaneous (catch-all
category).

<programlisting>
	+------------------+------------------+
	|  Etherboot core  |   Miscellaneous  |
	+------------------+------------------+
	|           Driver support            |
	+-------------------------------------+
	|           Hardware drivers          |
	+-------------------------------------+
	|              Hardware               |
	+-------------------------------------+
</programlisting>

These parts are mapped on the directory structure in the <filename>src</filename>
directory as follows:
<itemizedlist>
<listitem><para><filename>arch</filename>: Architecture specific files.
Each architecture has an own subdirectory, currently we have <filename>i386</filename>
and <filename>ia64</filename>.</para></listitem>
<listitem><para><filename>bin</filename>: The directory where all binary files are built.</para></listitem>
<listitem><para><filename>core</filename>: Etherboot core.</para></listitem>
<listitem><para><filename>drivers/disk</filename>: Drivers for floppies and hard disks.</para></listitem>
<listitem><para><filename>drivers/net</filename>: Drivers for NICs.</para></listitem>
<listitem><para><filename>firmware</filename>: BIOS-specific files.</para></listitem>
<listitem><para><filename>include</filename>: Include files.</para></listitem>
<listitem><para><filename>util</filename>: Utility programs that are needed for building, but not included in the resulting roms.</para></listitem>
</itemizedlist>
These directories are duplicated under <filename>arch</filename> where appropriate.
</para>

<sect2>
<title>Etherboot core</title>

<para>
The core of Etherboot handles the protocol for obtaining a network
identity and for loading data over the network.  This comprises the
files <filename>main.c</filename> (main program)
<filename>config.c</filename> (probe routines),
<filename>osloader.c</filename> (support for various load image
formats), <filename>nfs.c, proto*.c</filename> (support for network I/O)
and <filename>vsprintf.c</filename> (printing routines). (More here.)

</para>
</sect2>

<sect2>
<title>Drivers</title>

<para>
Generally each file represents a family of network adapters. For example
<filename>tulip.c</filename> handles all adapters that use a Tulip
compatible network controller, even if they are from different
manufacturers. <filename>3c90x.c</filename> handles a whole family of
related adapters from 3Com.

</para>
<para>
The interface between the core and the drivers is well-defined and
explained in <xref linkend="driver"/>.

</para>
<para>
The files <filename>timer.h</filename> and <filename>timer.c</filename>
provide routines for access to the second hardware timer of the PC. This
is used for implementing microsecond timeouts.

</para>
<para>
The files <filename>pci.h</filename> and <filename>pci.c</filename>
provide a PCI initialisation subsystem that is executed for PCI
adapters.

</para>
<para>
<filename>skel.c</filename> is a skeleton driver that an aspiring driver
writer can use as a starting point.

</para>
</sect2>

<sect2>
<title>Miscellaneous</title>

<para>
In this category are all the files that don't fit into the first two
categories.

</para>
</sect2>

<sect2>
<title>External auxiliary programs</title>

<para>
In Etherboot 5.0 and later there is the facility to load and run
external auxiliary programs. As Etherboot runs in high memory. All the
memory below that and above 0x10000 is fair game for loading. What if we
did not load the target operating system but instead loaded an external
program, one that returned to Etherboot after doing something. This
something could be a fancy menu system.  The advantage of this approach
is that the menu system does not have to be compiled into Etherboot,
which means it can be changed without changing ROMs, and can be much
larger.

</para>
<para>
How does such a menu program indicate to Etherboot which image is to be
loaded next? Several new features of Etherboot make this possible.
Firstly, a bit in the header of the loaded image is used to indicate
that the loaded program intends to return to Etherboot, as opposed to
never returning, in the case of an operating system. Next, the external
program is passed a pointer to the BOOTP/DHCP structure obtained by
Etherboot, which includes the filename field. Finally, the external
program can return one longword of status to Etherboot to indicate
various conditions.

</para>
<para>
So here's how the external menu program would work. Etherboot is told to
load an image which is a menu program. The program would present the
user with a list of images to choose from. The presentation can be as
simple as a numbered menu or as fancy as a point and click interface (if
you can arrange to interface to the pointer). When a particular image
has been chosen, the menu program alters the filename field in the
BOOTP/DHCP structure and returns a longword of status indicating that
Etherboot should retry the loading. Since the filename has been altered,
Etherboot will end up loading the desired image instead of the menu this
time around. Think of it as a program chaining facility.

</para>
</sect2>

</sect1>

<sect1>
<title>The development environment of Etherboot</title>

<para>
Etherboot is written in C, with certain routines written in x86
assembler for access to machine resources or to do things not possible
in C. The tools used are the GNU C compiler and GNU x86 assembler.
<command>ld</command> is used to link the object files.  An auxiliary
program called <command>makerom.pl</command> converts this binary into a
form suitable for writing into a ROM.

</para>
<para>
A Makefile coordinates all the building procedures. However there are
many network adapters that differ only in the PCI vendor and device IDs.
This information must be programmed into the ROM header using
<command>makerom</command>.  An auxiliary script called
<command>genrules.pl</command> scans all driver source files for the
device names and IDs and outputs make rules to a file called
<filename>Roms</filename> that is included by the main Makefile to
generate all the ROM images.  Another file included by Makefile is
<filename>Config</filename>, which contains user configurable build
parameters.

</para>
<para>
Let us take an example of a ROM image that we could build,
<filename>bin/mx98715.zrom</filename>. According to this line in the
file <filename>tulip.c</filename>:

<programlisting>
PCI_ROM(0x10d9, 0x0531, "mx98715", "Macronix MX987x5"),
</programlisting>

the driver code is in <filename>tulip.c</filename> and the vendor ID is
0x10d9 and the device ID is 0x0531. If one were to say <command>make
bin/mx98715.zrom</command>, the following actions happen:

</para>
<para>

<itemizedlist>
<listitem>

<para>
Any needed utilities such as <filename>bin/nrv2b</filename> are
built.

</para>
</listitem>
<listitem>

<para>
<filename>drivers/net/tulip.c</filename> is compiled to
<filename>bin/tulip.o</filename>.

</para>
</listitem>
<listitem>

<para>
The startup routine, <filename>arch/i386/core/start32.S</filename> is
assembled to <filename>bin/start32.o</filename>.

</para>
</listitem>
<listitem>

<para>
All the core Etherboot files, e.g. <filename>core/main.c</filename>,
<filename>osloader.c</filename>, etc, are compiled to corresponding
object files in <filename>bin/*.o</filename> and combined into an ar
archive, <filename>bin/bootlib.a</filename>, for convenience.

</para>
</listitem>
<listitem>

<para>
The startup routine (which must be first in the list of objects), the
driver object, <filename>bootlib.a</filename>, the platform specific
objects are linked to produce an ELF binary, linked to run at the
relocation address of Etherboot, currently 0x20000.  The ELF binary is
converted to an Etherboot binary using GNU utilities. This binary is
can be on non-x86 platforms by conversions. (To fill in later.) For the
x86 platform, we need to prepend loaders for the chosen load method.

</para>
</listitem>
<listitem>

<para>
The prepended ROM loaders, rloader, and prloader, are produced by
assembling <filename>arch/i386/prefix/loader.S</filename> with different
defines. The meaning of the prefixes are: rloader = basic ROM loader,
and prloader = PCI header basic ROM loader.  The loaders contain the
needed headers for the BIOS to recognise the code as an extension ROM.
See <xref linkend="extension"/> on the extension BIOS mechanism.

</para>
</listitem>
<listitem>

<para>
For example, in the case of <filename>bin/mx987x5.zrom</filename>, this
is for a PCI adaptor and we want a compressed ROM, so the loader is
prloader.  This is prepended to the Etherboot image to generate a ROM
image.

</para>
</listitem>
<listitem>

<para>
<command>makerom.pl</command> is run over this ROM image to pad it to
the size of a standard EPROM. (8 kB, 16 kB, 32 kB, etc.) The PCI IDs are
written into the image into the PnP structure at the right spots. A
string identifying the device and Etherboot version is written into the
unprogrammed bytes at the end of the ROM image, if space is available,
and a pointer to that written into the PnP structure. The vendor string
and the device string are normally printed by the PCI PnP BIOS at boot
time. Makerom also calculates the checksum (both for the PnP structure,
if present and for the whole image) and alters designated spare bytes in
the image so that the checksums come out right.  The image is then ready
to be written into an EPROM.

</para>
</listitem>
<listitem>

<para>
By prepending alternate loaders to the Etherboot image, we can load the
image from floppy, LILO/SYSLINUX, PXE or DOS.  In the case of floppy
loading, the preloader is called <filename>floppyload.bin</filename>. It
is one sector (512 bytes) long and loaded from the floppy, starting at
the beginning of the floppy. It then loads the blocks following itself,
which it assumes to be an Etherboot image, into memory, then jumps to
the start of it.

</para>

<para>
In the case of LILO/SYSLINUX booting, the preloader is
<filename>bin/liloprefix.bin</filename>. It contains what looks like a
floppy sector and a startup segment to LILO/SYSLINUX and makes
LILO/SYSLINUX "think" that this is a Linux kernel.

</para>
</listitem>
<listitem>

<para>
The loader for chaining from PXE is in
<filename>bin/pxeprefix.bin</filename>, and when prepended to an image,
produces a file that can be downloaded and executed by a PXE conforming
boot rom as a first stage loader. Etherboot then takes over the
remainder of the load process.

</para>
</listitem>
<listitem>

<para>
Yet another preloader is not for a device but for an OS environment.
This is <filename>bin/comprefix.bin</filename>, and when prepended to an
image, makes it look like a DOS .com executable, including the
peculiarity of starting at COM_SEGMENT:0x100. All it does however is
jump to the Etherboot image.

</para>
</listitem>
<listitem>

<para>
All the preceeding special preloaders have associated Makefile rules and
are created by asking for images with the appropriate suffix.  For
example, if one wanted an image for writing onto a floppy one would say:

<programlisting>
make bin/mx98715.zdsk
</programlisting>

</para>
</listitem>

</itemizedlist>

</para>

</sect1>

<sect1>
<title>Frequently asked questions</title>

<sect2>
<title>How portable is Etherboot?</title>

<para>
Work leading up to 5.2 made Etherboot much more portable. The platforms
on which Etherboot runs, other than the x86, are the Itanium and the
Hammer. The portability issues can be looked at in two categories:

</para>
<para>
Support routines needed for platforms need to be written.  Platform
independent and dependent code have been separated and it should be
straightforward to identify the support that is needed for running
Etherboot on a new platform.

</para>
<para>
Byte order, operand size and alignment issues in the core routines and
PCI drivers have been mostly dealt with, although there are some known
places where the code has not been made portable, e.g. longword access
of registers in the eepro100 driver.  We hope to find these bugs as time
goes by. In some cases, e.g. ISA bus NICs, there is no need to fix the
problem as the ISA bus only exists on the PC platform (unless somebody
attaches a NE2000 to a big-endian microcontroller and plans to run
Etherboot on it).

</para>
<para>
Here are the low-level services that need to provided: writing and
reading from the console, determining the size of memory, obtaining the
an elapsed time, inserting a boot vector to be called, and a microsecond
timer for short delays.  Depending on the target environment, these
services may be provided in different ways.

</para>
</sect2>

<sect2>
<title>How can I get Etherboot to boot a Cardbus (PCMCIA) or a USB NIC?</title>

<para>
Cardbus (PCMCIA) and USB NICs are interfaced to the CPU through their
respective bus controllers. Before Etherboot can address the registers
and memory on these NICs, it must initialise the bus controller
appropriately. In Linux this is done by the PCMCIA and USB subsystems.
In Etherboot, all this must be done by the code in the ROM. What needs
to be written is a subsystem like the PCI subsystem in Etherboot.
Volunteers are most welcome.

</para>
</sect2>

</sect1>

<sect1 id="driver">
<title>Writing an Etherboot Driver</title>

<sect2>
<title>Preliminaries</title>

<para>
So Etherboot does not have a driver for your network adapter and you
want to write one. You should have a good grasp of C, especially with
respect to bit operations. You should also understand hardware interfacing
concepts, such as the fact that the x86 architecture has a separate I/O
space and that peripherals are commanded with `out' instructions and
their status read with `in' instructions.  A microprocessor course such
as those taught in engineering or computer science curricula would have
given you the fundamentals. (Note to educators and students in computer
engineering: An Etherboot driver should be feasible as a term project
for a final year undergraduate student. I estimate about 40 hours of
work is required. I am willing to be a source of technical advice.)

</para>
<para>
Next you need a development machine. This can be your normal Linux
machine. You need another test machine, networked to the development
machine. This should be a machine you will not feel upset rebooting very
often. So the reset button should be in working condition. :-) It should
have a floppy drive on it but does not need a hard disk, and in fact a
hard disk will slow down rebooting. Alternatively, it should have
another network adapter which can netboot; see discussion further down.
Needless to say, you need a unit of the adapter you are trying to write
a driver for. You should gather all the documentation you can find for
the hardware, from the manufacturer and other sources.

</para>
</sect2>

<sect2>
<title>Background information</title>

<para>
There are several types of network adapter architecture. The simplest to
understand is probably programmed I/O. This where the controller reads
incoming packets into memory that resides on the adapter and the driver
uses `in' instructions to extract the packet data, word by word, or
sometimes byte by byte. Similarly, packets are readied for transmission
by writing the data into the adapter's memory using `out' instructions.
This architecture is used on the NE2000 and 3C509. The disadvantage of
this architecture is the load on the CPU imposed by the I/O. However
this is of no import to Etherboot (who cares how loaded the CPU is
during booting), but will be to Linux. Next in the sophistication scale
are shared memory adapters such as the Western Digital or SMC series, of
which the WD8013 is a good example. Here the adapter's memory is also
accessible in the memory space of the main CPU.  Transferring data
between the driver and the adapter is done with memory copy
instructions. Load on the CPU is light. Adapters in this category are
some of the best performers for the ISA bus.  Finally there are bus
mastering cards such as the Lance series for the ISA bus and practically
all good PCI adapters (but not the NE2000 PCI). Here the data is
transferred between the main memory and the adapter controller using
Direct Memory Access. Setting up the transfers usually involves a
sequence of operations with the registers of the controller.

</para>
</sect2>

<sect2>
<title>Structure of the code</title>

<para>
Examine the file <filename>skel.c</filename>, in the src directory,
which is a template for a driver. You may also want to examine a working
driver. You will see that an Etherboot driver requires 4 functions to be
provided:

</para>
<para>

<itemizedlist>
<listitem>
<para>
A probe routine, that determines if the network adapter is present
on the machine. This is passed a pointer to a `nic' struct, possibly a list of
candidate addresses to probe, and possibly a pointer to a `pci' struct.
This routine should initialise the network adapter if present.  If a
network adapter of the type the driver can handle is found, it should
save the I/O address at which it was found for use by the other
routines. In the case of ISA adapters, it may be passed a list of
addresses to try, or if no list is passed in, it may use an internal
list of candidate addresses. In the case of PCI adapters, the address
has already been found by the PCI support routines. Then it should
determine the Ethernet (MAC) address of the adapter and save it in
nic-&gt;node_addr. It should then initialise the
adapter.  Finally it should fill in the function pointers for the other
routines, and return the `nic' pointer. If it fails to find an adapter,
it should return 0.

</para>
<para>
The field rom_info in the `nic' struct contains, on entry to the probe
routine, a pointer to the structure rom_info, defined in <filename>etherboot.h</filename>.
This contains the segment address and length in shorts of the ROM as
detected by the BIOS.  These can be used by the driver to discriminate
between multiple instances of the same network adaptor on the bus, and
choose to activate only the one the ROM is installed on. For example,
the 3c509 hardware has a register indicating what address the ROM is
mapped at. Note that the driver should not reject "ROM segment
addresses" outside 0xC000 to 0xEE00 as this indicates booting from
floppy disk or other non-ROM media.

</para>
<para>
Initialising the adapter means programming the registers so that the
chip is ready to send and receive packets. This includes enabling the
appropriate hardware interface (10B2, 10BT) in the case of adapters with
more than one interface, and setting the right speed (10Mb, 100Mb) if
the hardware does not autosense and set it.  It also includes setting up
any memory buffers needed by the hardware, along with any necessary
pointers.

</para>
<para>
Note that you should program the receiver registers to allow broadcast
Ethernet packets to be received.  This is needed because other IP hosts
will do an ARP request on the diskless computer when it boots.

</para>
</listitem>
<listitem>

<para>
A disable routine, which puts the adapter into a disabled state.  This
is passed a pointer to a `nic' struct.  This is needed to leave the
adapter in a suitable state for use by the operating system which will
be run after Etherboot. Some adapters, if left in an active state, may
crash the operating system at boot time, or cannot be found by the
operating system.  This can be called from the probe routine.

</para>
</listitem>
<listitem>

<para>
A transmit routine, to send an Ethernet packet. This is passed a
pointer to a `nic' struct, the 6 byte Ethernet address of the destination,
a packet type (IP, ARP, etc), the size of the data payload in bytes, and
a pointer to the data payload. Remember the packet type and length fields
are in x86 byte order (little-endian) and the adapter's byte order may be
the reverse (big-endian). Note that the routine knows nothing about IP
(or any other type) packets, the data payload is assumed to be a filled
in packet, ready to transmit.

</para>
</listitem>
<listitem>
<para>
A poll routine, to check if a packet has been received and ready
for processing. This is passed a pointer to a `nic' struct. If a packet
is available, it should copy the packet from the adapter into the data
area pointed to by nic-&gt;packet, and set nic-&gt;packetlen to the length of
the data, and return 1, otherwise 0.

</para>
<para>
A few Ethernet controller chips will receive packets from itself, as
detected by having a source address of itself. You can throw these out
immediately on reception and not bother the upper layer with them.

</para>
</listitem>
</itemizedlist>
</para>

<para>
No routine needs to be public, all routines should be static and private
to the driver module. Similarly all global data in the driver should be
static and private.

</para>
<para>
If the NIC is a PCI adapter, create a struct pci_driver (as in
<filename>skel.c</filename>) and an array of struct pci_id:

<programlisting>
static struct pci_id skel_nics[] = {
PCI_ROM(0x0000, 0x0000, "skel-pci", "Skeleton PCI Adaptor"),
};
</programlisting>

Fill the pci_id array with one entry for each combination of pci vendor
id and pci device id that your driver can handle.  PCI_ROM is a a macro
defined in <filename>include/pci.h</filename>.  The arguments have the
following meaning: vendor id, device id, rom name and short description.
Since this information is also used to build the Makefile rules, you
must use the PCI_ROM macro and can't fill in the values directly.  Both
the pci vendor and device id must be given in hex form, no define is
allowed.  Additionally PCI_ROM must occur only once in a line and one
macro call must not span more than one line.  You can obtain the vendor
and device ids from the file
<filename>/usr/include/linux/pci.h</filename>. It is also displayed by
PCI BIOSes on bootup, or you can use the <command>lspci</command>
program from the pciutils package to discover the ids.

</para>
<para>
If the NIC is an ISA adapter, create a struct isa_driver (as in
<filename>skel.c</filename>) and one line like the following:

<programlisting>
ISA_ROM("skel-isa", "Skeleton ISA driver")
</programlisting>

in your driver source. The ISA_ROM macro is like the PCI_ROM without the
vendor/device ids. The same rules about formatting as in the PCI case
apply.

</para>
<para>
Only for special cases where the automatic generation of build rules via
the PCI_ROM and ISA_ROM entries does not work, add an entry to the here
document in <filename>genrules.pl</filename> so that the build process
will create Makefile rules for it in the file
<filename>bin/Roms</filename>.

</para>
<para>
The above mentioned structs and macros hold all information that
etherboot needs about your driver. In case you wonder how this works at
all although everything is declared static: The special build process
that is used by Etherboot (including linker scripts and some Perl magic)
packs the necessary information into public segments.

</para>
<para>
The Etherboot build process places a few restrictions on your driver:
If you need more than one .c file, the main file (that will contain
the PCI_ROM or ISA_ROM macro call) must contain #include directives for
the other files. They must not contain a PCI_ROM or ISA_ROM call.
See <filename>drivers/net/prism*</filename> for an example.

</para>

<sect3>
<title>Rom naming rules</title>
<para>
Currently there is no official rom naming convention in etherboot. Use
some descriptive name, but note that two ore more consecutive hyphens
(like in "my--rom") are not allowed, since "--" is the delimiter sign
for multiple-driver-roms.  Sometimes it is difficult to find a sensible
name, for example for "NICs" that are built in motherboard chipsets or
if you don't know the model name.  In this case we choose to name the
corresponding roms "driver-deviceid", like "eepro100-1035". Of course
you have to make sure that your rom name is unique in etherboot.

</para>
</sect3>

</sect2>

<sect2>
<title>Booting the code from a floppy</title>

<para>
Use the rule for bin/driver.fd0 to write another instance of the driver
to the floppy for testing. Use lots of printf statements to track where
execution has reached and to display the status of various variables and
registers in the code.  You should expect to do this dance with the
development machine, floppy disk and target machine many many times.

</para>
</sect2>

<sect2>
<title>Booting the test code with another Etherboot ROM</title>

<para>
There is another method of testing ROM images that does not involve
walking a floppy disk between the machines and is much nicer. Set up a
supported NIC with a boot ROM. Put the target NIC on the same machine
but at a non-conflicting I/O location. That is to say, your test machine
has two NICs and two connections to the LAN.  Then when you are ready to
test a boot image, use the utility <ulink
url="../mknbi.html">mknbi-rom</ulink> to create a network bootable image
from the ROM image, and set up bootpd/DHCPD and tftpd to send this over
the when the machine netboots.  Using Etherboot to boot another version
of itself is rather mind-boggling I know.

</para>
</sect2>

<sect2>
<title>Writing the code</title>

<para>
First set up the various required services, i.e. BOOTP/DHCP, tftp, etc.
on the development machine. You should go through the setup process with
a supported adapter card on a test machine so that you know that the
network services are working and what to expect to see on the test
machine.

</para>
<para>
If you are starting from a Linux driver, usually the hardest part is
filtering out all the things you do not need from the Linux driver. Here
is a non-exhaustive list: You do not use interrupts. You do not need
more than one transmit buffer. You do not need to use the most efficient
method of data transfer. You do not need to implement statistics
counting.  In general it is a good idea to use the latest Linux driver
as base, because it usually supports newer cards and has more bugs fixed
than older versions.  If the driver is written by Donald Becker, it is
probably best to start from the version available on <ulink
url="http://www.scyld.com/page/support/network/">this page</ulink>,
since the driver in the official kernel may be behind.  See also <xref
linkend="sync-linux"/>.

</para>
<para>
Generally speaking, the probe routine is relatively easy to translate
from the Linux driver. The exception is when you need to handle media
and speed switching. The transmit is usually straightforward, and
the receive a bit more difficult. The main problem is that in the Linux
driver, the work is split between routines called from the kernel and
routines triggered by hardware interrupts.  As mentioned before,
Etherboot does not use interrupts so you have to bring the work of
transmitting and receiving back into the main routines. The disable
routine is straightforward if you have the hardware commands.

</para>
<para>
When coding, first get the probe routine working. You will need to refer
to the programmer's guide to the adapter when you do this.  You can also
get some information by reading a Linux or FreeBSD driver. You may also
need to get the disable routine working at this time.

</para>
<para>
Next, get the transmit routine working. To check that packets are going
out on the wire, you can use tcpdump or ethereal on the development
machine to snoop on the Ethernet. The first packet to be sent out by
Etherboot will be a broadcast query packet, on UDP port 67. Note that
you do not need interrupts at all.  You should ensure the packet is
fully transmitted before returning from this routine.  You may also wish
to implement a timeout to make sure the driver doesn't get stuck inside
transmit if it fails to complete. A couple of timer routines are
available for implementing the timeout, see <filename>timer.h</filename>.
You use them like this (in pseudo-code):

<programlisting>
	for (load_timer2(TIMEOUT_VALUE);
		transmitter_busy &amp;&amp; (status = timer2_running()); )
		;
	if (status == 0)
		transmitter_timed_out;
</programlisting>

The timeout value should be 1193 per millisecond of wait. The maximum
value is 65535, which is about 54 milliseconds of timeout. If you just
need to delay a short time without needing to do other checks during the
timeout, you can call waiton_timer2(TIMEOUT_VALUE) which will load, then
poll the timer, and return control on timeout.

</para>
<para>
Please do not use counting loops to implement time-sensitive delays.
Such loops are CPU speed dependent and can fail to give the right delay
period when run on a faster machine.

</para>
<para>
Next, get the receive routine working. If you already have the transmit
routine working correctly you should be getting a reply from the
BOOTP/DHCP server. Again, you do not need interrupts, unlike drivers
from Linux and other operating systems. This means you just have to
read the right register on the adapter to see if a packet has arrived.
Note that you should NOT loop in the receive routine until a packet
is received. Etherboot needs to do other things so if you loop in the
poll routine, it will not get a chance to do those tasks. Just return
0 if there is no packet awaiting and the main line will call the poll
routine again later.

</para>
<para>
Finally, get the disable routine working. This may simply be a matter
of turning off something in the adapter.

</para>
</sect2>

<sect2>
<title>Things to watch out for</title>

<para>
Things that may complicate your coding are constraints imposed by the
hardware. Some adapters require buffers to be on word or doubleword
boundaries. See <filename>rtl8139.c</filename> for an example of this.
Some adapters need a wait after certain operations.

</para>
</sect2>

<sect2>
<title>Tidying up</title>

<para>
When you get something more or less working, release early. People on the
mailing lists can help you find problems or improve the code. Besides
you don't want to get run over by a bus and then the world never gets
to see your masterpiece, do you? :-)

</para>
<para>
Your opus should be released under GPL, BSD or a similar Open Source
license, otherwise people will have problems using your code, as most
of the rest of Etherboot is GPLed.

</para>
</sect2>

<sect2 id="sync-linux">
<title>Keeping your driver in sync with the Linux version</title>

<para>
Most Etherboot drivers are derived from their Linux counterparts.
Sooner or later the Linux driver where you started from will get
updated.  This may include bugfixes and support for new NICs.
Unfortunately there is no way to keep the Etherboot driver automatically
up to date, but if you keep the following rules in mind while porting it
can be made easier:

<itemizedlist>

<listitem><para>
State the version of the Linux driver in a comment in your Etherboot
driver.  This makes it easy to check to which Linux driver the Etherboot
driver corresponds </para></listitem>

<listitem><para>
Etherboot drivers should be small. Often a Linux driver contains way too
much code, but in many cases you can reuse some utility functions from
the Linux driver without blowing up the code size too much. In this
case, keep the order in which they are defined where possible, and avoid
code reformatting in general.  (re-indenting is ok, because
<command>diff</command> can ignore it with the -b switch). This makes it
easy to compare later versions with utilities like
<command>mgdiff</command>.

</para></listitem>
<listitem><para>
You can get the pci ids of all NIC drivers of a particular Linux kernel
with the utility <command>get-pci-ids</command> in
<filename>util</filename> and compare them to the entries in
<filename>bin/NIC</filename> in order to find out wether the Linux
kernel supports some new NICs.

</para></listitem>
</itemizedlist>
</para>
</sect2>
</sect1>

<sect1>
<title>A potted history of Etherboot</title>

<para>
In Linux circles Netboot appeared first. According to the docs Jamie
Honan was the person who coded up the first version and specified the
format of the tagged image files. This version used assembler code taken
from <ulink url="http://www.crynwr.com">packet drivers</ulink> to
interface to the hardware, only Western Digital (now SMC) NICs in the
first instance. It also required a DOS environment to compile. Later on
Gero Kuhlmann took over the development of Netboot and made tremendous
improvements to it. Among other things he created a harness that would
simulate just enough of a DOS environment so that unmodified packet
driver binaries could be used in a boot ROM.  This allows any NIC on the
market that has a packet driver to be used immediately. He also migrated
the development to a Linux (Unix) platform.

</para>
<para>
Etherboot was ported from FreeBSD by Markus Gutschke. He made it compile
under Linux and added code to support tagged images in addition to NFS
boot. Since tagged images are a more general mechanism and requires less
boot rom code, this has become the preferred loading method. Markus has
also coded most of the additional features between 2.0 and 3.0, such as
additional bootp tags, ANSI screen escapes, etc. Many of the features
common to Etherboot and Netboot, such as the tagged image format, the
support programs such as mknbi, and support in the Linux kernel for
diskless booting, are by Gero or Markus.

</para>
<para>
<ulink url="http://www.geocities.com/ken_yap_aus/">Ken Yap</ulink> came
to Etherboot a bit later. His original objective was to produce a 16 bit
version that could be used to netboot ELKS and other OSes on older CPUs.
As these things happen, he got enticed into improving the code, doing
structural rearrangement, and merging contributions from others, and is
now the primary maintainer of Etherboot.

</para>
<para>
In the early days, the Etherboot web page was hosted by the <ulink
url="http://www.slug.org.au/">Sydney Linux Users Group</ulink> web site.
Quite coincidentally and unrelatedly, Jamie Honan is one of the founding
members of SLUG, so the story has come a full circle here.  Since April
2000, Etherboot has been hosted at <ulink
url="http://sourceforge.net/">Sourceforge</ulink>. Sourceforge has
provided superb facilities for hosting community Open Source
development.

</para>
</sect1>

<appendix id="tagged">
<title>Draft Net Boot Image Proposal 0.3, June 15, 1997</title>

<para>
<author>
<firstname>Jamie Honan and Gero Kuhlmann, gero AT minix PERIOD han PERIOD de</firstname>
</author>
</para>

<para>
In order to provide more functionality to the boot rom code Jamie's
draft has been changed a little bit. All of Gero Kuhmnann's changes are
preceded and followed by <emphasis remap="bf">(gk)</emphasis>. All of Ken Yap's changes are
preceded and followed by <emphasis remap="bf">(ky)</emphasis>.
</para>

<sect1>
<title>Preamble - the why</title>

<para>
Whilst researching what other boot proms do (at least those implementing
TCP/IP protocols) it is clear that each 'does their own thing' in
terms of what they expect in a boot image.
</para>

<para>
If we could all agree on working toward an open standard, O/S suppliers
and boot rom suppliers can build their products to this norm, and be confident
that they will work with each other.
</para>

<para>
This is a description of how I will implement the boot rom for
Linux. I  believe it to be flexible enough for any OS that will be loaded
when a PC boots from a network in the TCP/IP environment.
</para>

<para>
It would be good if this could be turned into some form of standard.
</para>

<para>
This is very much a first draft. I am inviting comment.
</para>

<para>
The ideas presented here should be independant of any implementation.
In the end, where there is a conflict between the final of this draft, and an
implementation, this description should prevail.
</para>

<para>
The terms I use are defined at the end.
</para>

<para>
<emphasis remap="bf">(gk)</emphasis>IMPORTANT NOTE: The scope of this document starts at the
point where the net boot process gains control from the BIOS, to where
the booted image reaches a state from which there is no return to the
net boot program possible.<emphasis remap="bf">(gk)</emphasis>

</para>
</sect1>
<sect1>
<title>The target</title>

<para>
The target is to have a PC retrieve a boot image from a network in the TCP/IP
environment.
</para>

<para>
<emphasis remap="bf">(gk)</emphasis>The boot may take place from a network adaptor rom, from a
boot floppy.<emphasis remap="bf">(gk)</emphasis>
</para>

</sect1>

<sect1>
<title>Net Boot Process Description</title>

<para>
<emphasis remap="bf">(gk)</emphasis>The net boot process is started as a result of the PC boot
process. The net boot program can reside on a rom, e.g. on an adaptor
card, or in ram as a result of reading off disk.<emphasis remap="bf">(gk)</emphasis>
</para>

<para>
The boot process may execute in any mode (e.g. 8086, 80386) it desires.
When it jumps to the start location in the boot image, it must be in
8086 mode and be capable of going into any mode supported by the
underlying processor.
</para>

<para>
The image cannot be loaded into address spaces below 10000h, or between
A0000h through FFFFFh, or between 98000h through 9FFFFh.
<emphasis remap="bf">(gk)</emphasis>Only when the image is not going to return to the boot
process, all the memory is available to it once it has been started, so
it can relocate parts of itself to these areas.<emphasis remap="bf">(gk)</emphasis>
</para>

<para>
The boot process must be capable of loading the image into all other
memory locations. Specifically, where the machine supports this, this means
memory over 100000h.
</para>

<para>
The net boot process must execute the bootp protocol, followed by
the tftp protocol, as defined in the relevant rfc's.
</para>

<para>
The file name used in the tftp protocol must be that given by the bootp
record.
</para>

<para>
If less than 512 bytes are loaded, the net boot process attempts to
display on the screen any ascii data at the start of the image. The net
boot process then exits in the normal manner. For a boot prom, this
will allow normal disk booting. <emphasis remap="bf">(gk)</emphasis>Reference to DOS
deleted.<emphasis remap="bf">(gk)</emphasis>
</para>

<para>
When the first 512 bytes have been loaded, the boot process checks
for an initial magic number, which is defined later. If this number
is present, the net process continues loading under the control
of the image format. The image, which is described later, tells the
net boot process where to put this record and all subsequent data.
</para>

<para>
If no initial magic number is present the net boot process checks for a
second magic number at offset 510. If the magic number 510 = 55h, 511 =
AAh, then the net process continues. If this second magic number is not
present, then the net boot process terminates the tftp protocol,
displays an error message and exits in the normal manner.
</para>

<para>
If no initial magic number is present and the second one is, the net boot
process relocates the 512 bytes to location 7c00h. The net boot process
continues to load any further image data to 10000h up. This data can overwrite
the first 512 boot bytes. If the image reaches 98000h, then any further data is
continued to be loaded above 100000h. When all the data has been loaded, the
net boot process jumps to location 0:7c00.
</para>

<para>
<emphasis remap="bf">(gk)</emphasis>When the net boot program calls the image, it places 2
far pointers onto the stack, in standard intel order (e.g.
segment:offset representation).  The first far pointer which
immediately follows the return address on the stack, points to the
loaded boot image header. The second far pointer which is placed above
the first one, shows to the memory area where the net boot process
saved the bootp reply.
</para>

<para>
If the boot image is flagged as being returnable to the boot process,
the boot program has to provide the boot image with interrupt vector
78h. It's an interface to services provided by the net boot program
(see below for further description).
</para>

<para>
If the boot image is not flagged as being returnable to the boot
process, before the boot image is called, the boot program has to set
the system into a state in which it was before the net boot process has
started.<emphasis remap="bf">(gk)</emphasis>
</para>

</sect1>

<sect1>
<title>Image Format with Initial Magic Number.</title>

<para>
The first 512 bytes of the image file contain the image header,
and image loading information records. This contains all the
information needed by the net boot process as to where data
is to be loaded.
</para>

<para>
The magic number (in time-honoured tradition (well why not?)) is:

<programlisting>
        0 = 36h
        1 = 13h
        2 = 03h
        3 = 1Bh
</programlisting>

Apart from the two magic numbers, all words and double words are in PC
native endian.
</para>

<para>
Including the initial magic number the header record is:

<programlisting>
        +---------------------+
        |                     |
        | Initial Magic No.   |  4 bytes
        +---------------------+
        |                     |
        | Flags and length    |  double word
        +---------------------+
        |                     |
        | Location Address    |  double word in ds:bx format
        +---------------------+
        |                     |
        | Execute Address     |  double word in cs:ip format
        +---------------------+
</programlisting>

The Location address is where to place the 512 bytes. The net boot
process does this before loading the rest of the image. The location
address cannot be one of the reserved locations mentioned above, but
must be an address lower than 100000h.
</para>

<para>
The rest of the image must not overwrite these initial 512 bytes, placed
at the required location. The writing of data by the net boot process
into these 512 bytes is deprecated. These 512 bytes must be available for
the image to interogate once it is loaded and running.
</para>

<para>
The execute address is the location in cs:ip of the initial instruction
once the full image has been loaded. This must be lower than 100000h,
since the initial instructions will be executed in 8086 mode. When the
jump (actually a far call) is made to the boot image, the stack contains a
far return address, with a far pointer parameter above that, pointing
to the location of this header.
</para>

<para>
<emphasis remap="bf">(ky)</emphasis> If bit 31 in the flags is set, then the execute address is
interpreted as a linear 32-bit address, and a call is made to this
address. There is no restriction on the range of the execute address.
The arguments to the routine are: a pointer to an Etherboot specific
header, a pointer to the tagged image header, and a pointer to the bootp
reply.  The called routine may return to the boot loader.<emphasis remap="bf">(ky)</emphasis>
</para>

<para>
The flags and length field is broken up in the following way:
</para>

<para>
Bits 0 to 3 (lowest 4 bits) define the length of the non-vendor header in
double words. Currently the value is 4.
</para>

<para>
Bits 4 to 7 define the length required by the vendor extra information
in double words. A value of zero indicates no extra vendor information.
</para>

<para>
<emphasis remap="bf">(gk)</emphasis>Bit 8 is set if the boot image can return to the net boot
process after execution. If this bit is not set the boot image does
never return to the net boot process, and the net boot program has to
set the system into a clean state before calling the boot
image.<emphasis remap="bf">(gk)</emphasis>
</para>

<para>
<emphasis remap="bf">(ky)</emphasis>Bit 31 is set if the execute address of the boot image is a
linear 32-bit address to be called. The boot image may return to the
boot loader.<emphasis remap="bf">(ky)</emphasis>
</para>

<para>
<emphasis remap="bf">(gk+ky)</emphasis>Bits 9 to 30 are reserved for future use and must be set to
zero.<emphasis remap="bf">(gk+ky)</emphasis>
</para>

<para>
After this header, and any vendor header, come the image loading information
records. These specify where data is to be loaded, how long it is, and
communicates to the loaded image what sort of data it is.
</para>

<para>
The format of each image loading information record is :

<programlisting>
          +---------------------+
          | Flags, tags and     |  double word
          | lengths             |
          +---------------------+
          |                     |
          | Load Address        |  double word
          +---------------------+
          |                     |
          | Image Length        |  double word
          +---------------------+
          |                     |
          | Memory Length       |  double word
          +---------------------+
</programlisting>

Each image loading information record follows the previous, or the header.
</para>

<para>
The memory length, image length and load address fields are unsigned 32
numbers. They do not have the segment:offset format used by the 8086.
</para>

<para>
The flags, tags and lengths field is broken up as follows:
</para>

<para>
Bits 0 to 3 (lowest 4 bits) are the length of the non vendor part of this
header in double words. Currently this value is 4.
</para>

<para>
Bits 4 to 7 indicate the length of any vendor information, in double words.
</para>

<para>
Bits 8 to 15 are for vendor's tags. The vendor tag is a private number that
the loaded image can use to determine what sort of image is at this particular
location.
</para>

<para>
Bits 16 to 23 are for future expansion and should be set to zero.
</para>

<para>
Bits 24 to 31 are for flags, which are defined later.
</para>

<para>
Vendors may place further information after this information record, and
before the next. Each information record may have a different vendor
length.
</para>

<para>
There are two restrictions on vendor information.
</para>

<para>
One is that the header and all information records that the net boot process
is to use fall within the first 512 bytes.
</para>

<para>
The second restriction is that the net boot process must ignore all
vendor additions. The net boot process may not overwrite vendor supplied
information, or other undefined data in the initial 512 bytes.
</para>

<para>
The flags are used to modify the load address field, and to indicate
that this is the last information record that the net boot process should
use.
</para>

<para>
Bit 24 works in conjunction with bit 25 to specify the meaning of the
load address.

<programlisting>
  B24    B25

   0     0    load address is an absolute 32 number

   1     0    add the load address to the location one past the last byte
	      of the memory area required by the last image loaded.
	      If the first image, then add to 512 plus the location
	      where the 512 bytes were placed

   0     1    subtract the load address from the one past the
	      last writeable location in memory. Thus 1 would
	      be the last location one could write in memory.

   1     1    load address is subtracted from the start of
	      the last image loaded. If the first image, then
	      subtract from the start of where the 512 bytes were
	      placed
</programlisting>

(For convenience bit 24 is byte 0 of the flag field)
</para>

<para>
Bit 26 is the end marker for the net boot process. It is set when
this is the last information record the net boot process should
look at. More records may be present, but the net boot process will not
look at them. (Vendors can continue information records out past the 512
boundary for private use in this manner).
</para>

<para>
The image length tells the net boot process how many bytes are to be loaded.
Zero is a valid value. This can be used to mark memory areas such as
shared memory for interprocessor communication, flash eproms, data in eproms.
</para>

<para>
The image length can also be different from the memory length. This allows
decompression programs to fluff up the kernel image. It also allows a file
system to be larger then the loaded file system image.
</para>

<para>
Bits 27 through 31 are not defined as yet and must be set to zero until
they are.
</para>

</sect1>

<sect1>
<title>Boot prom entry points.</title>

<para>
<emphasis remap="bf">(gk)</emphasis>As mentioned above the net boot process has to provide
interrupt 78h as an entry point in case, the returnable flag (bit 9 of
the flags field in the image header) of the boot image has been set.
When calling this interface interrupt, the caller has to load the AH
register with a value indicating the type of operation requested:

<programlisting>
00h  -  Installation check
       Input:  none
       Output: AX  -  returns the value 474Bh
	       BX  -  flags indicating what further services are
		      provided by the net boot program:
		       Bit 0 - packet driver interface (see below)
		       Bits 1 to 15 are unused and have to be zero

01h  -  Cleanup and terminate the boot process services. This will
       also remove the services provided by interrupt 87h.
       Input:  none
       Output: none
</programlisting>

Further functions are not yet defined. These functions are only available
to boot images which have the first magic number at the beginning of the
image header, and have the returnable flag set in the flags field.
</para>

<para>
In order to provide compatibility with net boot programs written to match
an earlier version of this document, the loaded image should check for the
existence of interrupt 78h by looking at it's vector. If that's 0:0, or if
it does not return a proper magic ID after calling the installation check
function, the boot image has to assume that the net boot program does not
support this services interrupt.
</para>

<para>
If the bit 0 of register BX of function 00h is set, the boot program has
to provide a <ulink url="http://www.crynwr.com">packet driver</ulink>
interface at interrupt 79h as described in the packet driver interface
standard, version 1.09, published by FTP Software, Inc., which is not
repeated here. It serves as an interface to the system's network card.
It is important to note that the net boot process has to provide a clean
packet driver interface without any handles being defined when the boot
image gets started. It is expected that the boot image sets up it's own
TCP/IP or other network's stack on top of this packet driver interface.
When the boot image returns to the net boot process, it has to return a
clean packet driver interface as well, without any handles being
defined.<emphasis remap="bf">(gk)</emphasis>

</para>

</sect1>

<sect1>
<title>Example of a boot image.</title>

<para>
Here is an example of how the boot image would look for Linux:

<programlisting>
  0x1B031336,  /* magic number */
  0x4,         /* length of header is 16 bytes, no vendor info */
  0x90000000,  /* location in ds:bx format */
  0x90000200,  /* execute address in cs:ip format */

	       /* 2048 setup.S bytes */
  0x4,	       /* flags, not end, absolute address, 16 bytes this
		  record, no vendor info */
  0x90200,     /* load address - note format */
  0x800,       /* 4 8 512 byte blocks for linux */
  0x800,

	       /* kernel image */
  0x4,	       /* flags, not end, absolute address, 16 bytes this
		  record, no vendor info */
  0x10000,     /* load address - note format */
  0x80000,     /* 512K (this could be shorter */
  0x80000,

	       /* ramdisk for root file system */
  0x04000004,  /* flags = last, absolute address, 16 bytes this
		  record, no vendor info *//
  0x100000,    /* load address - in extended memory */
  0x80000,     /* 512K for instance */
  0x80000,
	       /* Then follows linux specific information */
</programlisting>

</para>

</sect1>

<sect1>
<title>Terms</title>

<para>
When I say 'the net boot process', I mean the act of loading the image
into memory, setting up any tables, up until the jump to the required
location in the image.

</para>
<para>
The net booting program executes the net boot process. The net boot
program may be a rom, but not neccassarily. It is a set of instructions
and data residing on the booting machine.

</para>
<para>
The image, or boot image,  consists of the data loaded by the net boot
process.

</para>
<para>
When I say 'the PC boot process', I mean the general PC rom bios boot
process, the setting up of hardware, the scanning for adaptor roms, the
execution of adaptor roms, the loading in of the initial boot track. The
PC boot process will include the net boot process, if one is present.

</para>
<para>
When I say client, I mean the PC booting up.

</para>
<para>
When I say 'image host', I mean the host where the boot image is comming
from.  This may not have the same architecture as the client.

</para>
<para>
The bootp protocol is defined in RFC951 and RFC1084. The tftp protocol
is defined in RFC783. These are available on many sites.

</para>
<para>
A bootp server is the machine that answers the bootp request. It is not
neccessarily the image host.

</para>
<para>
"Can" and "may" means doesn't have to, but is allowed to and might.
"Must" means just that. "Cannot" means must not.

</para>
</sect1>

<sect1>
<title>References</title>

<para>
Stevens, W.R 1990, Unix Network Programming, Prentice Hall,
Englewood Cliffs, N.J., 1990
</para>

</sect1>

</appendix>

<appendix id="compressor">
<title>Compression algorithm, 1 July 1997</title>

<para>
<author>
<firstname>Markus Gutschke, gutschk AT math PERIOD uni-muenster PERIOD de</firstname>
</author>
</para>

<para>
The  compressor achieves  an  average compression  rate of 60% of the
original size which is on par with "gzip". It seems that you cannot do
much better for compressing  compiled  binaries.  This means that  the
break even  point  for using compressed  images is   reached, once the
uncompressed size approaches 1.5kB. We  can stuff more than 12kB  into
an 8kB EPROM and more than 25kB into an 16kB EPROM.   As there is only
32kB of RAM  for both the uncompressed  image  and its BSS  area, this
means that 32kB EPROMs will hardly ever be required.

</para>
<para>
The compression  algorithm uses a  4kB  ring buffer  for buffering the
uncompressed data. Before   compression starts,  the  ring buffer   is
filled  with spaces (ASCII  character  0x20).  The algorithm tries  to
find repeated  input sequences of a  maximum length of  60 bytes.  All
256 different input  bytes  plus the 58 (60   minus a threshold of  2)
possible  repeat lengths form a set  of 314 symbols. These symbols are
adaptively Huffman encoded.  The  algorithm starts out with a Huffmann
tree  that  assigns equal code lengths    to each of  the  314 symbols
(slightly favoring the repeat  symbols over symbols for regular  input
characters), but  it will be changed whenever  the frequency of any of
the symbols  changes. Frequency counts are  kept in 16bit  words until
the total number of compressed codes totals 2&circ;15.  Then, all frequency
counts will be halfed (rounding to the bigger number).  For unrepeated
characters (symbols 0..255) the Huffman code  is written to the output
stream.  For repeated characters the  Huffmann code, which denotes the
length of the repeated character sequence, is written out and then the
index in the ring buffer is computed.   From this index, the algorithm
computes  the offset   relative to  the current  index  into  the ring
buffer. Thus,  for typical input data,  one would expect that short to
medium range offsets are more frequent  than extremely short or medium
range to long range offsets. Thus the  12bit (for a 4kB buffer) offset
value  is statically Huffman encoded  using a precomputed Huffman tree
that favors  those  offset  values    that  are deemed to   be    more
frequent. The  Huffman encoded offset  is  written to the output  data
stream,  directly  following the code  that   determines the length of
repeated characters.

</para>
<para>
This algorithm, as implemented in the  C example code, looks very good
and  its operating parameters are   already well optimized. This  also
explains   why  it achieves     compression ratios    comparable  with
"gzip". Depending on the input data, it sometimes excells considerably
beyond what "gzip -9" does, but this  phenomenon does not appear to be
typical. There are some flaws with  the algorithm, such as the limited
buffer  sizes, the  adaptive  Huffman tree  which takes  very  long to
change, if    the input  characters  experience   a sudden   change in
distribution, and the static Huffman   tree for encoding offsets  into
the  buffer.   The slow  changes of   the  adaptive  Huffman  tree are
partially counteracted by  artifically keeping  a 16bit precision  for
the frequency counts, but  this does not  come into play until 32kB of
compressed data is output, so  it does not  have any impact on our use
for "etherboot", because  the BOOT Prom  does not support uncompressed
data of more then 32kB (c.f. doc/spec.doc).
</para>

<para>
Nonetheless,  these problems  do  not  seem  to affect  compression of
compiled  programs very much.  Mixing  object code with English  text,
would not work too  well though, and  the algorithm should be reset in
between. Actually, we  might  gain a little  improvement, if  text and
data   segments    were compressed  individually,    but   I have  not
experimented with this option, yet.

</para>
</appendix>

<appendix>
<title>Copying conditions of the compression code, 1 July 1997</title>

<para>
<author>
<firstname>Markus Gutschke, gutschk AT math PERIOD uni-muenster PERIOD de</firstname>
</author>
</para>

<para>
The compression code as implemented in "lzhuf.c" was taken from a BBS
program written by Joachim Schurig &lt;jschurig AT zedat PERIOD
fu-berlin PERIOD de&gt;. He states that the code can be used freely for
programs that are covered by a "freeware" license. This probably
includes both BSD style licenses and the GPL.

</para>
<para>
The code in "zloader.asm" is a reimplementation of the uncompressor. It
has been written from scratch and is hereby placed under the
conditions of the GNU General Public License (GPL). The algorithm is
outlined in <xref linkend="compressor"/>.

</para>
<para>
Thus, there are no copyright problems with using this code, but there
still might be difficulties with software patents. These patents are
not legal in most parts of the world, but if you live in a country
that honors software patents then you should verify that using these
algorithms is legally permitted. Unless you are absolutely sure, that
there are no legal obstacles, you should use the code for educational
purposes only (this assumes that your educational institution is
exempted from patent laws). The author cannot be held responsible for
using the program code in violation of applicable local laws.

</para>
<para>
If you are aware of patents that might affect the legality of using
the code in some parts of the world, please let me know.

</para>
</appendix>

</article>
